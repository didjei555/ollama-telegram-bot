import logging
import os
import signal
from typing import Dict, List, Optional, Union
from concurrent.futures import ThreadPoolExecutor
import asyncio
import platform
from dataclasses import asdict

from telegram import Update, BotCommand
from telegram.error import TimedOut, NetworkError
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    Application,
)
import ollama

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
class Config:
    MAX_CONTEXT_LENGTH = 20
    OLLAMA_MODEL = "–í–µ—Ä—Å–∏—è –ò–ò –Ω–∞–ø—Ä–∏–º–µ—Ä = deepseek-r1:8b"
    OLLAMA_TIMEOUT = 30  # seconds
    MAX_WORKERS = 5
    TELEGRAM_TIMEOUT = 10  # seconds for Telegram API
    TELEGRAM_TOKEN = '–¢–µ–ª–µ–≥—Ä–∞–º —Ç–æ–∫–µ–Ω'
    MAX_MESSAGE_LENGTH = 4000  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è Telegram
    MESSAGE_SPLIT_DELAY = 1.5  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —á–∞—Å—Ç—è–º–∏
    RETRY_DELAY = 2.0  # –ó–∞–¥–µ—Ä–∂–∫–∞ –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–µ


class TelegramBot:
    def __init__(self):
        self.last_error: Optional[str] = None
        self.application: Optional[Application] = None
        self.shutdown_event = asyncio.Event()
        self.executor = ThreadPoolExecutor(max_workers=Config.MAX_WORKERS)
        self.user_contexts: Dict[int, List[Dict[str, str]]] = {}
        self.context_lock = asyncio.Lock()
        self.initialized = False

    async def post_init(self, application: Application) -> None:
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞"""
        try:
            # –°–ø–∏—Å–æ–∫ —Ç–æ–ª—å–∫–æ —Ç–µ—Ö –∫–æ–º–∞–Ω–¥, –∫–æ—Ç–æ—Ä—ã–µ –º—ã —Ö–æ—Ç–∏–º –≤–∏–¥–µ—Ç—å –≤ –º–µ–Ω—é
            commands = [
                BotCommand("start", "–ù–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ"),
                BotCommand("pullmodel", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏"),
                BotCommand("clear", "–û—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç"),
                BotCommand("health", "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞"),
                BotCommand("help", "–°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥")]
            
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞—à–∏ –∫–æ–º–∞–Ω–¥—ã –∏ —É–¥–∞–ª—è–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ
            await application.bot.set_my_commands(commands)
            self.initialized = True
            logger.info("Bot initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize bot commands: {e}", exc_info=True)
            raise

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        try:
            await update.message.reply_text(
                "–ü—Ä–∏–≤–µ—Ç! –Ø —á–∞—Ç-–±–æ—Ç. –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?"
            )
        except Exception as e:
            logger.error(f"Error in start: {e}", exc_info=True)

    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
        try:
            help_text = (
                "–í–æ—Ç —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥:\n"
                "/start - –ù–∞—á–∞–ª—å–Ω–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ\n"
                "/pullmodel - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–¥–µ–ª–∏\n"
                "/clear - –û—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç\n"
                "/health - –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞\n"
                "/help - –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–∞–Ω–¥"
            )
            await update.message.reply_text(help_text)
        except Exception as e:
            logger.error(f"Error in help: {e}", exc_info=True)

    async def health_check(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞ (/health)"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Ollama
            ollama_status = "‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
            model_status = "‚ùå –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–∞"
            model_details = ""

            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Ollama –ø—Ä–æ—Å—Ç—ã–º –∑–∞–ø—Ä–æ—Å–æ–º
                await asyncio.wait_for(
                    asyncio.get_event_loop().run_in_executor(
                        self.executor, lambda: ollama.show(Config.OLLAMA_MODEL)
                    ),
                    timeout=5.0,
                )
                ollama_status = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω"
                model_status = "‚úÖ –ù–∞–π–¥–µ–Ω–∞"
                
                # –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ –º–æ–¥–µ–ª–∏
                model_info = await asyncio.get_event_loop().run_in_executor(
                    self.executor, lambda: ollama.show(Config.OLLAMA_MODEL)
                )
                if isinstance(model_info, dict):
                    model_details = f" (—Ä–∞–∑–º–µ—Ä: {model_info.get('size', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')})"
                elif hasattr(model_info, 'size'):
                    model_details = f" (—Ä–∞–∑–º–µ—Ä: {model_info.size})"
                
            except Exception as e:
                # –ï—Å–ª–∏ show –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ list
                try:
                    models = await asyncio.wait_for(
                        asyncio.get_event_loop().run_in_executor(
                            self.executor, lambda: ollama.list()
                        ),
                        timeout=5.0,
                    )
                    
                    ollama_status = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω"
                    
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –æ—Ç–≤–µ—Ç–∞
                    models_list = []
                    if isinstance(models, dict) and 'models' in models:
                        models_list = models['models']
                    elif hasattr(models, 'models'):
                        models_list = models.models
                    
                    # –ò—â–µ–º –Ω–∞—à—É –º–æ–¥–µ–ª—å
                    for model in models_list:
                        model_name = model.get('name') if isinstance(model, dict) else getattr(model, 'name', '')
                        if model_name == Config.OLLAMA_MODEL:
                            model_status = "‚úÖ –ù–∞–π–¥–µ–Ω–∞"
                            if isinstance(model, dict):
                                model_details = f" (—Ä–∞–∑–º–µ—Ä: {model.get('size', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')})"
                            elif hasattr(model, 'size'):
                                model_details = f" (—Ä–∞–∑–º–µ—Ä: {model.size})"
                            break
                    
                    if model_status != "‚úÖ –ù–∞–π–¥–µ–Ω–∞":
                        model_status = "‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–∞"
                        
                except Exception as e:
                    logger.error(f"Ollama health check failed: {e}", exc_info=True)
                    self.last_error = str(e)

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            status = (
                "üîÑ –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞:\n"
                f"‚Ä¢ Ollama: {ollama_status}\n"
                f"‚Ä¢ –ú–æ–¥–µ–ª—å: {Config.OLLAMA_MODEL}{model_details} - {model_status}\n"
                f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –¥–∏–∞–ª–æ–≥–æ–≤: {len(self.user_contexts)}\n"
                f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞: {self.last_error or '–ù–µ—Ç'}"
            )

            await update.message.reply_text(status)
        except Exception as e:
            logger.error(f"Health check error: {e}", exc_info=True)
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è")

    async def pull_model(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–π –º–æ–¥–µ–ª–∏ (/pullmodel)"""
        try:
            await update.message.reply_text(f"–ò—Å–ø–æ–ª—å–∑—É–µ–º–∞—è –º–æ–¥–µ–ª—å: {Config.OLLAMA_MODEL}")
        except Exception as e:
            logger.error(f"Error in pullmodel: {e}", exc_info=True)

    async def clear_context(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û—á–∏—Å—Ç–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (/clear)"""
        user_id = update.effective_user.id
        try:
            async with self.context_lock:
                if user_id in self.user_contexts:
                    self.user_contexts[user_id] = []
                    await update.message.reply_text("–ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω!")
                else:
                    await update.message.reply_text("–ö–æ–Ω—Ç–µ–∫—Å—Ç —É–∂–µ –ø—É—Å—Ç!")
        except Exception as e:
            logger.error(f"Error clearing context: {e}", exc_info=True)
            await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.")

    def _get_ollama_response_sync(self, context: List[Dict[str, str]]) -> str:
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ ThreadPool"""
        try:
            response = ollama.chat(
                model=Config.OLLAMA_MODEL,
                messages=context,
                options={"timeout": Config.OLLAMA_TIMEOUT * 1000},
            )

            # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            logger.debug(f"Ollama raw response: {response}")

            # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
            if hasattr(response, 'message') and hasattr(response.message, 'content'):
                return response.message.content
            elif isinstance(response, dict) and 'message' in response:
                if isinstance(response['message'], dict) and 'content' in response['message']:
                    return response['message']['content']
                elif hasattr(response['message'], 'content'):
                    return response['message'].content
            
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∫–æ–Ω—Ç–µ–Ω—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–µ—Å—å –æ—Ç–≤–µ—Ç –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
            return str(response)

        except Exception as e:
            logger.error(f"Ollama error: {e}", exc_info=True)
            return "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞"

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –¥–ª–∏–Ω–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤"""
        user_id = update.effective_user.id
        user_message = update.message.text

        try:
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
            async with self.context_lock:
                if user_id not in self.user_contexts:
                    self.user_contexts[user_id] = []
                self.user_contexts[user_id].append({"role": "user", "content": user_message})
                
                if len(self.user_contexts[user_id]) > Config.MAX_CONTEXT_LENGTH:
                    self.user_contexts[user_id] = self.user_contexts[user_id][-Config.MAX_CONTEXT_LENGTH:]

            # –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –æ—Ç –º–æ–¥–µ–ª–∏
            response = await asyncio.get_event_loop().run_in_executor(
                self.executor, self._get_ollama_response_sync, self.user_contexts[user_id].copy()
            )

            # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
            async with self.context_lock:
                self.user_contexts[user_id].append({"role": "assistant", "content": response})

            # –£–ª—É—á—à–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
            max_length = Config.MAX_MESSAGE_LENGTH
            if len(response) <= max_length:
                await update.message.reply_text(response)
                return

            # –†–∞–∑–±–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏
            parts = []
            current_part = ""
            
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ä–∞–∑–±–∏—Ç—å –ø–æ –∞–±–∑–∞—Ü–∞–º
            paragraphs = response.split('\n\n')
            for para in paragraphs:
                if len(current_part) + len(para) + 2 > max_length:
                    if current_part:
                        parts.append(current_part.strip())
                    current_part = para
                else:
                    if current_part:
                        current_part += "\n\n" + para
                    else:
                        current_part = para
            
            if current_part:
                parts.append(current_part.strip())
            
            # –ï—Å–ª–∏ —Ä–∞–∑–±–∏–≤–∫–∞ –ø–æ –∞–±–∑–∞—Ü–∞–º –Ω–µ –¥–∞–ª–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, —Ä–∞–∑–±–∏–≤–∞–µ–º –ø–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º
            if len(parts) == 0 or any(len(p) > max_length for p in parts):
                parts = []
                current_part = ""
                sentences = response.split('. ')
                for sent in sentences:
                    if len(current_part) + len(sent) + 2 > max_length:
                        if current_part:
                            parts.append(current_part.strip() + ".")
                        current_part = sent
                    else:
                        if current_part:
                            current_part += ". " + sent
                        else:
                            current_part = sent
                if current_part:
                    parts.append(current_part.strip())

            # –ï—Å–ª–∏ –≤—Å—ë –µ—â—ë –µ—Å—Ç—å –¥–ª–∏–Ω–Ω—ã–µ —á–∞—Å—Ç–∏, —Ä–∞–∑–±–∏–≤–∞–µ–º –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
            if any(len(p) > max_length for p in parts):
                parts = [response[i:i+max_length] for i in range(0, len(response), max_length)]

            # –û—Ç–ø—Ä–∞–≤–∫–∞ —á–∞—Å—Ç–µ–π —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
            for i, part in enumerate(parts, 1):
                try:
                    prefix = f"üìù –ß–∞—Å—Ç—å {i}/{len(parts)}:\n" if len(parts) > 1 else ""
                    await update.message.reply_text(prefix + part)
                    
                    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                    await asyncio.sleep(1.5)  # –£–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
                    
                except Exception as e:
                    logger.error(f"Error sending message part {i}: {e}")
                    # –ü—Ä–æ–±—É–µ–º –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ—â—ë —Ä–∞–∑ —Å –º–µ–Ω—å—à–∏–º —Ä–∞–∑–º–µ—Ä–æ–º
                    try:
                        chunk_size = 3000
                        chunks = []
                        for j in range(0, len(part), chunk_size):
                            chunks.append(part[j:j+chunk_size])
                        for chunk in chunks:
                            await update.message.reply_text(chunk)
                            await asyncio.sleep(1.5)
                    except Exception as retry_error:
                        logger.error(f"Retry failed: {retry_error}")
                        await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —á–∞—Å—Ç—å –æ—Ç–≤–µ—Ç–∞")

        except Exception as e:
            logger.error(f"Error handling message: {e}", exc_info=True)
            self.last_error = str(e)
            await update.message.reply_text("‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è")

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """–ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
        error = context.error
        logger.error(f"Error: {error}", exc_info=True)

        if isinstance(update, Update) and update.message:
            try:
                self.last_error = str(error)
                await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            except Exception as e:
                logger.error(f"Error in error handler: {e}", exc_info=True)

    async def shutdown(self, signal=None) -> None:
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏"""
        if signal:
            logger.info(f"Received exit signal {signal.name}...")

        logger.info("Shutting down...")
        self.shutdown_event.set()

        if self.application and self.initialized:
            try:
                await self.application.stop()
                await self.application.shutdown()
            except Exception as e:
                logger.error(f"Error during shutdown: {e}", exc_info=True)

        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É–ª –ø–æ—Ç–æ–∫–æ–≤
        self.executor.shutdown(wait=True)
        logger.info("Bot stopped gracefully")

    async def run(self) -> None:
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"""
        max_retries = 3
        retry_delay = 5  # seconds

        try:
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è Unix-—Å–∏—Å—Ç–µ–º)
            if platform.system() != "Windows":
                try:
                    loop = asyncio.get_running_loop()
                    for sig in (signal.SIGTERM, signal.SIGINT):
                        loop.add_signal_handler(
                            sig, lambda s=sig: asyncio.create_task(self.shutdown(s))
                        )
                except NotImplementedError:
                    logger.warning("Signal handling not supported on this platform")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω
            if not Config.TELEGRAM_TOKEN:
                raise ValueError("TELEGRAM_BOT_TOKEN environment variable is not set")

            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
            for attempt in range(max_retries):
                try:
                    self.application = (
                        ApplicationBuilder()
                        .token(Config.TELEGRAM_TOKEN)
                        .post_init(self.post_init)
                        .concurrent_updates(True)
                        .pool_timeout(30)
                        .read_timeout(Config.TELEGRAM_TIMEOUT)
                        .write_timeout(Config.TELEGRAM_TIMEOUT)
                        .connect_timeout(Config.TELEGRAM_TIMEOUT)
                        .build()
                    )

                    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
                    handlers = [
                        CommandHandler("start", self.start),
                        CommandHandler("pullmodel", self.pull_model),
                        CommandHandler("clear", self.clear_context),
                        CommandHandler("health", self.health_check),
                        CommandHandler("help", self.help),
                        MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message),
                    ]
                    for handler in handlers:
                        self.application.add_handler(handler)

                    self.application.add_error_handler(self.error_handler)

                    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
                    logger.info("Starting bot...")
                    await self.application.initialize()
                    await self.application.start()

                    if hasattr(self.application, "updater") and self.application.updater:
                        await self.application.updater.start_polling()
                    else:
                        logger.warning("Application has no updater set")

                    logger.info("Bot started successfully")
                    break

                except (TimedOut, NetworkError) as e:
                    logger.error(f"Attempt {attempt + 1}/{max_retries} failed: {e}")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(retry_delay)
                        continue
                    raise
                except Exception as e:
                    logger.error(f"Initialization failed: {e}", exc_info=True)
                    raise

            # –î–ª—è Windows –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—á–Ω—ã–π —Ü–∏–∫–ª —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π KeyboardInterrupt
            if platform.system() == "Windows":
                try:
                    while True:
                        await asyncio.sleep(1)
                except KeyboardInterrupt:
                    await self.shutdown()
            else:
                await self.shutdown_event.wait()

        except asyncio.CancelledError:
            pass
        except Exception as e:
            logger.critical(f"Application error: {e}", exc_info=True)
        finally:
            await self.shutdown()


def main() -> None:
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"""
    bot = TelegramBot()
    try:
        asyncio.run(bot.run())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.critical(f"Unexpected error: {e}", exc_info=True)


if __name__ == "__main__":
    main()